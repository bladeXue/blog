# 深入理解递归算法

## 什么是递归

先来看看[wiki](https://en.wikipedia.org/wiki/Recursion)对递归的定义：

> **递归**（英语：Recursion），又译为**递回**，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。递归一词还较常用于描述以自相似方法重复事物的过程。

递归其实在现实中有很多非常常见的类似行为，比如“一个男人在看电视，电视播放的广告里有个男人在看电视，电视播放...”或者著名的德罗斯特效应：

![droste effect](./images/droste-effect.jpg "droste-effect")

这种都属于“自己调用了自己”的无限行为，但它们都不是递归，因为递归包含了两个意思：

1. **递**：递推，是对自身模式的不断复制
2. **归**：回归（有些地方也称回溯），每一层递归的结果都会对最终结果产生影响

仅仅单方面无限循环并不是递归，只能称为递推，而回溯性是众多递归算法的核心。如果把递归行为看作上维基查词条A，结果出现了一个你不认识的词条B，你只能继续查词条B，查B的时候又出现了C，最终你查到了Z终于全部理解了，但不要忘了你的任务是查解词条A，然后你开始不停返回，直到返回词条A，继续阅读下面的内容，这个过程就同时完成了**传递**和**回归**，而传递的最远端就是末尾词条Z。同样地，可能在阅读词条的时候，你可能会遇到多个疑惑词，于是你反复地查阅新词然后返回，但是最终你还是会回到词条A的。

## 递归模式的数学来源

众所周知程序模式都来自数学（计算机本身就是数学分支），计算机出现之前，类似递归的方法其实在数学中就有很普遍的应用了，这里我们来看两个例子。

### 数学归纳法

我们在高中的时候都学过数学归纳法，这是一种基于演绎的命题证明方法，常用于证明一个过程或者序列，步骤如下：

1. 证明“当![n=0](https://latex.codecogs.com/svg.latex?\small&space;n=0)时命题成立。”（0在这里没有特殊含义，仅仅是因为其作为自然数集合中中最小值，当作起点）
2. 证明“若假设在![n=m](https://latex.codecogs.com/svg.latex?\small&space;n=m)时命题成立，可推导出在![n=m+1](https://latex.codecogs.com/svg.latex?\small&space;n=m+1)时命题成立。”（m代表任意自然数）

在这种模式下，需要一个**特例**（证明1.）和一个**增长性成立**（证明2.），便可以把情况推广到所有例子上。

### 等比数列

## 分治法

## 典型的递归算法

## 递归的2个特征


## 如何编写一个递归算法

### 1. 分治法分析问题 
### 2. 递归法编写代码
### 3. 最小化原则和透明行为
### 4. 算法分析善后

## x道题继续理解递归
## 进阶：递归的操作系统基础
## 进阶：递归函数论，深入计算机之魂
## 进阶：区别递归和迭代
## 进阶：函数式语言中的递归
## 进阶：递归的等价实现
## 进阶：递归的回溯性质的应用
## 进阶：递归类算法的复杂度分析
## 进阶：常见的递归算法扫盲
## 进阶：递归的缺点，什么时候不适合递归
## 进阶：递归的缺点，如何进行尾递归优化

## 写在最后

## 参考
