# 深入理解递归算法

## 什么是递归

准确来说，递归并不是某一种具体的算法，而是一种算法策略，递归算法其实是一类算法，这其中所有使用递归作为基本策略的算法都可以称为递归算法
<!-- more -->
在[维基百科](https://zh.wikipedia.org/wiki/递归)中，是这么定义递归这种行为的：
>递归（英语：Recursion），又译为递回，在数学与计算机科学中，是指在**函数的定义中使用函数自身的方法**。递归一词还较常用于描述以自相似方法重复事物的过程。例如，当两面镜子相互之间近似平行时，镜中嵌套的图像是以无限递归的形式出现的。也可以理解为自我复制的过程。

仅仅看定义的话很难真的理解什么是递归，但是其实递归在现实中无处不在，看下面几个拥有递归属性的例子：
1. GNU项目的命名展开其实是递归的：GNU => GNU's not unix => (GNU's not unix)'s not unix => ...
2. 能讲一年的故事：从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，故事说从前有座山，山里有座庙，庙里有个老和尚给小和尚讲故事，故事说从前有座山，山里有座庙...
3. 德罗斯特效应也是一种经典的递归行为，可以用来做出很不错的视觉艺术品，如下图：
<img src="/images/algorithm/德罗斯特效应.jpg" title="Droste Effect" alt="droste effect" style="max-width:30%;margin:auto;" />

## 递归的3个基本特征

在正式使用递归解决问题前，我们需要理解递归的一些原则，首先来看一个经典例子，也就是著名的兔子问题（斐波那契数列），这个问题原本的描述如下：

> 假设一对刚出生的小兔一个月后就能长成大兔，再过一个月就能生下一对小兔，并且此后每个月都生一对小兔，一年内没有发生死亡，问：一对刚出生的兔子，一年内繁殖成多少对兔子？

简单了解完一下问题，其实很轻松就可以写出这么个序列\[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233...]，其中第k个位置表示第k个月份的兔子数目，很轻易可以看到第12位是144，也就是一年能生产144对兔子，且这个数组中除开头2位外的任何1位都有fib\[k]=fib\[k-1]fib\[k-2]

在此我们直接给出斐波那契数列的递归结构的Java实现：

```java
public class Fib {

    // fib means Fibonacci sequence斐波那契数列
    private static int fib(int n) {
        if (n <= 1)
            return 1;   // 递归出口
        else
            return fib(n - 1) + fib(n - 2); // 递归核心
    }

    public static void main(String[] args) {
        for (int i = 0; i < 12; i++) {
            System.out.print(fib(i) + " ");
            // output: 1 1 2 3 5 8 13 21 34 55 89 144
        }
    }
}
```

简单观察一下上面的代码，这个代码是非常经典的递归实现（估计每个程序员接触的第一次递归就是斐波那契数列了），观察这个代码，可以发现一个递归算法的**3个基本特征**：

1. 出口（真正实意）
见实例代码的第6行，之所以叫出口是因为我们在不断递归的过程中，总要有一个结束退出的条件吧，不然不就成死循环了吗。注意这个地方定义的也是递归算法的最基础的真实操作，考虑我们调用fib(3)，其实是在调用fib(2)+fib(1)，其中fib(2)=fib(1)+fib(0)，fib(1)和fib(0)则是我们定义的真正有自己的数值的函数项，其余的fib(4)一类的函数项不过是在堆叠fib(1)和fib(0)，最终fib(3)=(fib(1)+fib(0))+fib(1)=3
2. 递归子（前置依赖和目标透明化抽象）
也就是所谓的递归核心，见代码第8行，通过不停调用递归子，最终我们的函数项会到达递归出口，获得“真实数值”后，回溯堆叠，获得函数项的具体值，可以参考以下步骤：
- 我们调用fib(10)，程序发现无法直接计算fib(10)，只能将其拆解成fib(9)+fib(8)
- 程序继续运行，发现自己无法直接计算fib(9)和fib(8)，只能将fib(9)拆分成fib(8)+fib(7)，fib(8)拆分成fib(7)+fib(6)
- 现在我们的fib(10)变成了\[fib(8)+fib(7)]+\[fib(7)+fib(6)]
- 程序继续执行，发现自己无法直接计算fib(8)，于是继续拆分，直到我们的表达式变成了一堆fib(0)和fib(1)的加法，这里的fib(0)和fib(1)就是我们前文说的递归出口。这样的**以此类推**是递归的基本思想
- 当程序把fib(10)拆分成一堆fib(0)和fib(1)的加法时，它发现自己终于可以直接计算fib(0)和fib(1)的数值了，它非常感动，开始做具体的加法计算，通过fib(0)和fib(1)算出fib(2)，循环往替
- 一层层计算后，回到了我们最开始的表达式fib(10)=\[fib(8)+fib(7)]+\[fib(7)+fib(6)]，此时算出fib(8)=34，fib(7)=21，fib(6)=13
- 最终获得了fib(10)=fib(9)+fib(8)=34+55=89
3. 衔尾蛇原理（递归函数体必出现函数头）
和递归子类似，有时候这个第3点和第2点是合并的，依旧见代码第8行，无论是隐式调用还是显式调用，递归代码必会在自己的函数体内出现自己的函数头（调用自己），基本上看到这个特征，那就是递归算法了

这里给出一张非常经典的老图，可以配合直观感受一下递归过程：
<img src="/images/algorithm/recursion/fib.png" title="fib_old" alt="fib_old" style="max-width:950%;margin:auto;" />

## 分析一个递归问题

## 如何编写一个合法的递归函数：步骤和原则

构建一个递归函数是很容易的，主要麻烦在于，递归这种行为适合计算机算东西，但是不怎么适合人脑去算东西，所以理解递归问题不能用人的思维去理解，但是除此之外，按照一些标准步骤，很轻松就可以完成一个递归算法的实现。其实现的关键依旧是上文所提及的递归基本特征，也就是递归出口和递归子

在这里给出递归函数的一个经典模板：
```javascript
func(mode) {
    if (endCondition) {      
        end;    //递归出口
    } else {
        func(smaller_mode)  //递归子，调用本身
    }
}
```





## x道题继续了解递归

阶乘
汉诺塔
树的递归结构
迷宫问题
next数组和状态机

练习：排列组合，递归求反字符串，单调有界序列必有极限

## 递归的等价算法

等价数组算法
树的遍历中的两种不同方案（队列+栈）

## 进阶：递归实现的操作系统基础

进程递归的堆栈基础
ollydbg的显示
jvm递归基础和字节码调试

## 进阶：递归函数论-深入计算机之魂

## 进阶：递归和迭代的区别

## 进阶：递归类算法的复杂度分析

## 算法应用：适合递归的场景和常见递归算法

## 递归的缺点：什么时候不适合递归

栈溢出
又慢又胖

## 缺点的对策：尾递归优化和其它优化

理解递归的本质及其计算机基础是优化递归代码的关键

## 写在最后



