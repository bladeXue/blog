# 理解补码

基本上工科的在大一时都修过C语言，国内普遍用的的谭浩强的课本，开篇就讲了一大堆的原码反码，但都是流水账，基本上大家都学得迷迷糊糊的，跟着老师背了一堆“反补诀窍”，但始终没明白补码到底是个什么东西。

## 补码和整数减法

首先我们都知道计算机的核心是CPU，而且电路属性是建立在二进制代数上的，所以CPU只认识二进制，我们平时用的十进制和十六进制数，在执行层面也是转换成二进制后进行计算的。但是，这里面有一个问题，为了保证数字电路工程的纯粹，那就是CPU很大程度上，只会做整数加法，乘法则是通过一个标记数，多次调用加法得来的。

那减法怎么办？CPU实现减法的策略也很简单，想要减去某个数字A，那就加上A的相反数就行了。

我们这样定义一个相反数：

1. 对于数字A和数字B。
2. 如果存在![](https://latex.codecogs.com/gif.latex?A&plus;B=0)成立，则称A和B互为相反数，记作![](https://latex.codecogs.com/gif.latex?B=-A)，以上。

你可能会觉得这两者没有区别，但是对CPU来说，这是实现减法的关键。

## 位数溢出

假设我们拥有一个8位CPU，给定一个数字A，十进制表示为15，其8位二进制表示为00001111，又给定一个数字B，其8位二进制表示为11110001，A和B相加为9位二进制100000000，但是我们的CPU是8位的，所以第9位被进位丢弃，结果是00000000，把流程写下来：

1. 有![ ](https://latex.codecogs.com/gif.latex?A=[00001111]_{8})和![ ](https://latex.codecogs.com/gif.latex?B=[11110001]_{8})。
2. 等式![](https://latex.codecogs.com/gif.latex?[00001111]_{8}&plus;[11110001]_{8}=[00000000]_{8})成立。
3. 根据相反数定义，A和B相加为零，互为相反数。

数字B其实就是A的补码，其十进制表示为-15，通过巧妙地运用进位溢出，就变相通过相反数来完成了一次减法，15-15=0是这样，通过补码就完成CPU的减法。

## 补码的求法

其实你只要观察一下![ ](https://latex.codecogs.com/gif.latex?A=[00001111]_{8})和![ ](https://latex.codecogs.com/gif.latex?B=[11110001]_{8})，其实很轻易就能看出来补码是怎么算的：为了构造加法完成后能触发满值溢出1个数，补码就是取反后加上一个溢出补位数字。

## 总结

补码是通过合理溢出来让计算机实现减法操作，整数减法和浮点数减法略有区别，但是原理是相似的。
